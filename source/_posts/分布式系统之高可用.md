---
title: 分布式系统之高可用
comments: true
date: 2018-07-06 15:24:38
time: 1530861878
tags:
categories: 分布式
---


## 什么是高可用

高可用（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指通过设计减少系统不能提供服务的时间。

假设系统一直能够提供服务，我们说系统的可用性是100%。

如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。

很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。

百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过www.baidu.com 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度HA最高的褒奖。



## 如何保障系统的高可用

为了保证站点可响应和可用，需要三样东西：**数据备份(backup)**、**冗余(redundancy)** 和 **响应性(responsiveness)**。

**备份**可以将节点恢复到它崩溃之前的状态；**冗余**保证即使在一个或更多的节点停止提供服务的情况下，站点仍能继续运行；**响应性**保证系统在实际生产环境中可用。 

执行备份有多种方法，方法的选择取决于你的需求。你需要即时恢复到一个精确的时间点吗？如果是就必须满足执行基于时间点恢复(point-in-time-recovery，PITR)必需的条件。你想在备份的同时保持服务器正常运行吗？如果是就必须保证使用的备份方法不会扰乱运行中的服务器，比如在线备份。

冗余是通过硬件副本来实现的，让几个实例同时运行，并通过**复制**在几个机器上保存相同数据的多个可用副本。如果其中一个机器失效，可以切换到另一个拥有相同数据副本的机器。 

有了这些之后，还需要**自动故障转移**。每次出现故障需要人工介入恢复势必会增加系统恢复服务难度。



## 常见架构实践

![HA](http://sixianed.com/images/HA/06A24AF9-AD73-4149-96C1-9F851D1AE845.jpg)

常见互联网分布式架构如上：

>（1）客户端层：典型调用方是浏览器browser或者手机应用APP
>（2）反向代理层：系统入口，反向代理 
>（3）站点应用层：实现核心应用逻辑，返回html或者json
>（4）服务层：如果实现了服务化，就有这一层
>（5）数据-缓存层：缓存加速访问存储
>（6）数据-数据库层：数据库固化数据存储

整个系统的高可用，又是通过每一层的冗余+自动故障转移来综合实现的：



### 客户端层->反向代理层 的高可用

![2040B9C9-7D41-4352-9518-2C8C3B0721CC](http://sixianed.com/images/HA/2040B9C9-7D41-4352-9518-2C8C3B0721CC.png)

是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。


自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。

### 反向代理层->站点层 的高可用

![AB5E56CF-2844-4434-8F92-4955245ED4B3](http://sixianed.com/images/HA/AB5E56CF-2844-4434-8F92-4955245ED4B3.png)

是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。


自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。

### 站点层->服务层 的高可用

![0C01A303-2806-4548-853F-FEBF2B07B0CF](http://sixianed.com/images/HA/0C01A303-2806-4548-853F-FEBF2B07B0CF.png)

是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。
![F5A44F6C-BF64-46D8-9633-00F7781D44FD](http://sixianed.com/images/HA/F5A44F6C-BF64-46D8-9633-00F7781D44FD.png)

自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。

### 服务层>缓存层 的高可用

![9ACD8A3E-481F-4E6F-8551-B968D6FC35CC](http://sixianed.com/images/HA/9ACD8A3E-481F-4E6F-8551-B968D6FC35CC.png)

是通过缓存数据的冗余来实现的。
缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。

![A5305F70-9ED0-4178-AB49-1705F80B218C](http://sixianed.com/images/HA/A5305F70-9ED0-4178-AB49-1705F80B218C.png)


缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。
以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。

![9540B47B-9AE3-4ED7-BFA7-5A43DCDF84D3](http://sixianed.com/images/HA/9540B47B-9AE3-4ED7-BFA7-5A43DCDF84D3.png)

自动故障转移：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。 
说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。
这类允许“cache miss”的业务场景，缓存架构的建议是：

![6C3F196A-44AA-4468-B8C7-7CEA6EBD8D03](http://sixianed.com/images/HA/6C3F196A-44AA-4468-B8C7-7CEA6EBD8D03.png)

将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。

![E042A660-25EA-47AA-9551-82A5D04306E5](http://sixianed.com/images/HA/E042A660-25EA-47AA-9551-82A5D04306E5.png)


缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。

### 服务层>数据库层“读” 的高可用

大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。

![A301AE50-AD7F-4ADA-8895-D820CBDB01ED](http://sixianed.com/images/HA/A301AE50-AD7F-4ADA-8895-D820CBDB01ED.png)


既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。

![655F86C8-1541-4806-881B-6AB6A21311A6](http://sixianed.com/images/HA/655F86C8-1541-4806-881B-6AB6A21311A6.png)


自动故障转移：当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。

### 服务层>数据库层“写” 的高可用

![EA10F89E-727D-4EDF-81FB-3F32BBCDD205](http://sixianed.com/images/HA/EA10F89E-727D-4EDF-81FB-3F32BBCDD205.png)

是通过写库的冗余来实现的。以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。

![390B168D-03C1-4459-A4FC-FE8016F92B11](http://sixianed.com/images/HA/390B168D-03C1-4459-A4FC-FE8016F92B11.png)

自动故障转移：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。