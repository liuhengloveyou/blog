---
title: 密码应用学
comments: true
date: 2018-01-12 16:35:26
time: 1515746126
tags:
categories: web
---



## 密码应用学简介

大家常讲的密码家，可理解密码分析学或密码使用学。**密码使用学**指的是一种为了达到隐藏消息含义目的而使用的密文书写的科学。
作为程序员我们只需要关心密码应用学的问题。

 ![密码使用学](https://www.sixianed.com/images/WX20170616-144049@2x.png)

我们要做的是使用密码学现有的成果来保证通信的安全, 部署正确的密码能解决安全的三个核心需求:保持秘密(机密性),验证身份(真实性),以及保证传输安全(完整性).

密码使用学本身可以分为以下三个主要分支：

- **对称密码算法(Symmetric Algorithm):**

 用户双方共享一个密钥，并使用相同的加密方法和解密方法。

- **非对称密码算法(Asymmetric Algorithm)或公钥算法(Public-Key Algorithm):**

  Whitfield Diffie, Martin Hellman, Ralph Merkle在1976年提出了非对称加密算法。用户有自己的密钥和公钥。

- **密码协议(Cryptographic Protocol):**

  粗略的讲，密码协议主要针对是密码算法的应用规则，一个典型代表就是TLS。

![密码学的主要领域](https://www.sixianed.com/images/440ADAD4-2FDA-4BE6-BC07-5BF89E0EA49D.png)

## 对称加密算法

对称加密算法的特点是双方共享一个密钥,并使用相同的加解密方法. 密钥是保密的算法是公开的.

假设一个应用场景：有两个用户－－Alice和Bob－－想通过一个不安全的信道进行通信.而有一个名叫Oscar的坏蛋试图窃听. 而Alice和Bob更愿意避开Oscar的窃听.

![不安全信道上的通信](https://www.sixianed.com/images/CF6E6710-6FE7-4247-B2CC-665410FDE39E.png)

对称密码可以解决这种情况: Alice使用对称算法加密她的消息x, 得到密文y; Bob接收到密文y, 解密得到消息x.

![安全信道上的通信](https://www.sixianed.com/images/6A57E560-0100-4FA7-839B-90910DB7E2F1.png)


PS: x称为明文; y称为密文; k称为密钥


对称密码学分成分组密码和序列密码两部分，两者差异较大，易于区分。

![分组密码和序列密码](https://www.sixianed.com/images/QQ20170620-101232@2x.png)

#### 序列密码

序列密码单独加密每个位，它是通过将密钥序列中的每个位与每个明文位相加实现的。同步序列密码的密码序列公取决于密钥,而异步序列密码的密钥序列则取决于密钥和密文.

目前公开的序列密码算法主要有RC4、SEAL等。

#### 分组密码

分组密码每次使用相同的密钥加密整个明文位分组.这意味着对给定分组内任何明文的加密都依赖于与它在一个分组内的其它所有明文位.

DES(Data Encytption Standard, 数据加密标准)是上一代主流分组密码算法, 已经不再安全. 现在大家会选择AES(Advanced Encryption Standard,高级加密标准).

AES有128位/192位/256位三种不同的密钥长度抵抗蛮力攻击, 目前还没有出现成功破译AES的攻击.

#### 分组密码加密操作模式

分组密码每次只能加密长度等于分组长度的单块数据,通常实际应用中人们需要加密不只是8字节或16字节的单个明文分组,使用分组密码算法加密长明文的方式有很多种, 简单介绍常见的几种. 

其中ECB和CFB要求明文长度必须是密码算法分组大小的整数倍,比如在AES中应该是16字节的整数倍.不满足要求的明文必须对其进行填充.填充方式有多种, 其中一种是: 在明文后附加单个"1"位,然后跟据需要附加足够多的"0"位,直到明文长度达到分组长度的整数倍.如果明文长度刚好是分组的整数倍, 则填充的所有位刚好形成了一个单独的额外分组.

其中CFB,OFB,CTR三种模式可将分组密码用作序列加密的基本模块.

* 电子密码本模式 (electronic code book mode, ECB)

 把需要加密的消息按照分组密码的分组长度分为数个块，并对每个块进行独立加密。如果消息长度不是分组长度的整数倍, 则在加密前必须将其填充为分组长度的整数倍.

 ![Ecb_encryption](https://www.sixianed.com/images/Ecb_encryption.png)
 ![Ecb_decryption](https://www.sixianed.com/images/Ecb_decryption.png)

ECB的优点是分组同步不是必须的；最大的问题是加密是高度确定的，明文中重复的排列会反映在密文中。并且当密文被篡改时，解密后对应的明文分组也会出错，且解密者察觉不到密文被篡改了。也就是说，ECB不能提供对密文的完整性校验。

* 密码分组链接模式 (cipher block chaining mode, CBC)

 每个明文块先与前一个密文块进行异或后再进行加密. 在这种方法中每个密文块都依赖于它前面的所有明文块。

 同时,为了保证每条消息的唯一性，在第一个块中需要使用初始化向量.

 ![Cbc_encryption](https://www.sixianed.com/images/Cbc_encryption.png)
 ![Cbc_decryption](https://www.sixianed.com/images/Cbc_decryption.png)

* 输出反馈模式 (Output feedback, OFB)

 可以将分组密码变成同步的序列密码的加密方案.在OFB模式中密钥序列以分组产生, 然后与一组明文进行异或操作就实现了对明文的加密.

 OFB模式的思路是, 首先使用分组密码加密IV,得到的密钥输出为b位的密钥序列的第一个集合;将前一个密钥输出反馈给分组密码进行加密,即可计算出密钥序列位的下一个分组;不断重复这个过程.

 ![Ofb_encryption](https://www.sixianed.com/images/Ofb_encryption.png)
 ![Ofb_decryption](https://www.sixianed.com/images/Ofb_decryption.png)


 OFB模式形成了一个同步序列密码,因为此密钥序列即不依赖明文,也不依赖密文.所以加密操作与解密操作完全相同,与标准序列密码(RC4)非常相似.

* 密码反馈模式 (Cipher feedback, CFB)

 类似于CBC,可以将块密码变为自同步的流密码;工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：

 ![Cfb_encryption](https://www.sixianed.com/images/Cfb_encryption.png)
 ![Cfb_decryption](https://www.sixianed.com/images/Cfb_decryption.png)

* 计数器模式 (Counter CTR)

   CTR模式也被称为整数计数模式模式(Integer Counter Mode, ICM)和SIC模式(Segmented Integer Counter)。使用分组密码作为序列密码的另一种模式;与OFB和CFB模式一样密钥序列也是以分组方式计算的。在CTR模式中有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。

 ![Ctr_encryption](https://www.sixianed.com/images/Ctr_encryption.png)
 ![Ctr_decryption](https://www.sixianed.com/images/Ctr_decryption.png)



- GCM(Galois/Counter Mode)

  GCM基于并行化设计，可以提供高效的吞吐率和低成本、低延迟。其本质是消息在变型的CTR模式下加密，密文结果与密钥以及消息长度信息在GF(2128)域上相乘。该标准还同时制定了仅支持MAC的工作模式即GMAC。

  GCM模式使用两个函数：带密钥的Hash函数GHASH，以及计数器每次增1 的CTR模式的GCTR。

![GHASH](https://www.sixianed.com/images/GHASH.png)
　GHASHH(X)函数将Hash密钥H和位串X作为输入，经过转化函数可表示成：
　　　　GHASHH(X) = (X1•Hm)⊕(X2•Hm-1)⊕...⊕(Xm-1•H2)⊕(Xm•H)

​	该式非常适合快速实现，如果使用相同的Hash密钥认证多个消息，那么H2，H3，...能够通过一次预计算来对所有消息进行认证，并且待认证的数据分组(X1，X2，...，Xm)能够并行处理，因为每组计算都相互独立。

![GCRT](https://www.sixianed.com/images/GCRT.png)

inc32(S)函数对S的最右32位增1并取模232，其余位不变。最后一次加密生成MSB，根据Xn'的长度截取后再与Xn'异或产生Yn'

![GCM](https://www.sixianed.com/images/GCM.png)

(1)令 H = E(K , 0128)
(2)定义分组J0如下
	如果len(IV) = 96，则令J0 = IV || 031 || 1。
	如果len(IV) ≠ 96，则令 s = 128⌈len(IV)/128⌉ - len(IV) 　　
	并令J0 = GHASHH(IV || 0s+64 || [len(IV)64])　　　　//[s+64+len(IV)]%64 = 0,说白了就是使输入满足刚好可分整数组的长度
(3)令C = GCRTK(inc32(J0) , P)
(4)令u = 128⌈len(C)/128⌉ - len(C) 　　　　v = 128⌈len(A)/128⌉ - len(A) 　　//目的也是为了满足分组长度(5)定义分组S如下
	S = GHSASHH(A || 0v || C || ou || [len(A)]64 || [len(C)64])
(6)令 T = MSBt(GCTRK(J0 , S))，这里t是支持的MAC长度


## 非对称加密算法

一个对称密码系统必须满足两个属性:

1. 加密与解密使用相同的密钥。
2. 加密和解密函数非常类似(DES完全相同)。

那么就会存在一些问题：

1. Alice和Bob必须使用安全的信道建立密钥。
2. 在拥有n个用户的网络中, 如果每每对用户之间都需要一个密钥对, 那将是非常多的密钥
3. 对Alice或Bob的欺骗没有防御机制

非对称加密可以克服这些缺点。与对称加密一样, 非对称加密也有一个密钥; 但不同的是, 它同时还有一个公钥。主要用于对称密码的**密钥交换传输**和**数字签名**。

重要的非对称加密算法家族有:

* 整数分解方案；因式分解大整数是非常困难的。突出代表是RSA。
* 离散对数方案；有不少算法都是基于有限域内离散对数问题。典型代表包括Diffie-Hellman密钥交换，Elgamal加密或数字签名算法DSA.
* 椭圆曲线(EC)方案；离散对数算法的一个推广就是椭圆曲线方案. 典型例子包括椭圆曲线Diffie-Hellman密钥交换(ECDH)和椭圆曲线数字签名算法(ECDSA).

以上三种算法家族都是基于数论函数，它们的一个突出特征就是要求算术运算的操作数和密钥都非常长。显而易见, **操作数和密钥长度越长算法就越安全**, 计算性能也就越差。

### RSA

Whitfield Diffie 和Martin Hellman 于1976年在他们的论文中提出公钥密码后, 一个崭新的密码学分枝涌现出来. 1977年, Ronald Rivest, Adi Shamir 和 Leonard Adleman提出了一种实现方案, 即RSA;

提出RSA算法的本意并不是为了取代对称密码, 而且它比诸如AES的密码要慢很多, 主要用途是为了安全地交换对称密码的密钥. 实际上RSA通常与类似AES的对称密码一起使用, 其中真正用来加密大量数据的是对称密码.

### Diffie-Hellman
Diffie-Hellman密钥交换(DHKE)是由Whitfield Diffie 和Martin Hellman在1976年提出的, 也是在公开文献中发布的第一个非对称方案。

它是一种秘钥协商的解决方案，而不是加解密方案。即它允许双方通过不安全的信道进行交流，得到一个共同密钥，提供给对称加密算法为后面的报文加密。所以秘钥必须和其他一种加密算法结合使用。

Diffie-Hellman密钥交换算法的有效性依赖于计算离散对数的难度。其安全性依赖于这样一个事实：虽然计算以一个素数为模的指数相对容易，但计算离散对数却很困难。对于大的素数，计算出离散对数几乎是不可能的。

Diffie-Hellman算法的特征：

1. 仅当需要时才生成密钥，减小了将密钥存储很长一段时间而致使遭受攻击的机会。

2. 除对全局参数的约定外，密钥交换不需要事先存在的基础结构。

然而，也存在许多不足：

1. 没有提供双方身份的任何信息。

2. 它是计算密集性的，因此容易遭受阻塞性攻击，即对手请求大量的密钥。受攻击者花费了相对多的计算资源来求解无用的幂系数而不是在做真正的工作。

3. 没办法防止重演攻击。

4. 容易遭受中间人的攻击。第三方C在和A通信时扮演B；和B通信时扮演A。A和B都与C协商了一个密钥，然后C就可以监听和传递通信量。

Oakley算法是对Diffie-Hellman密钥交换算法的优化，它保留了后者的优点，同时克服了其弱点。

Oakley算法具有五个重要特征：

1. 它采用称为cookie程序的机制来对抗阻塞攻击。
2. 它使得双方能够协商一个全局参数集合。
3. 它使用了现时来保证抵抗重演攻击。
4. 它能够交换Diffie-Hellman公开密钥。
5. 它对Diffie-Hellman交换进行鉴别以对抗中间人的攻击。

Oakley可以使用三个不同的鉴别方法：

1. 数字签名：通过签署一个相互可以获得的散列代码来对交换进行鉴别；每一方都使用自己的私钥对散列代码加密。散列代码是在一些重要参数上生成的，如用户ID和现时。
2. 公开密钥加密：通过使用发送者的私钥对诸如ID和现时等参数进行加密来鉴别交换。
3. 对称密钥加密：通过使用某种共享密钥对交换参数进行对称加密，实现交换的鉴别。

###  ECC
椭圆曲线密码编码学(Elliptic Curves Cryptography)是已确定具有实用性的三种公钥算法家族中最新的一个成员。
ECC是建立在基于椭圆曲线的离散对数问题上的密码体制：给定椭圆曲线上的一个点P，一个整数k，求解Q=kP很容易；给定一个点P、Q，知道Q=kP，求整数k确是一个难题。

ECC使用较短的操作数, 可提供与RSA或离散对数系统同等的安全等级, 所需要的操作数长度之长大概为 160 ~ 256 位比 1024 ~ 3072 位. ECC基于推广的离散对数问题, DL协议(比如Diffie-Hellman密钥交换)也可以使用椭圆曲线实现.

在很多情况中, ECC在性能和带宽上都比RSA和离散对数(DL)方案更具有优势。

### ECDH

ECC算法和DH结合用于密钥协商，这个密钥交换算法称为ECDH。通信双方可以在不安全的公共媒体上完成密钥协商操作，而不必事先交换任何私有信息。 该共享机密协议通常用于派生密钥材料，对称算法（如AES算法）可以使用密钥材料对后续消息进行加密。

ECDH 协议依赖两个公共参数：p 和 g。 参数 p 是一个大的质数，参数 g 是一个小于 p 的整数。 这两个参数通过不安全的线路进行交换。 Alice 和 Bob 收到这两个公共参数后，选择私有整数。 Alice 选择了 a，Bob 选择了 b。 这些值称为私钥。

然后，Alice 和 Bob 使用公共参数及其私钥创建公钥。 Alice 使用 (g^a) mod p，Bob 使用 (g^b) mod p。 这些是非对称密钥，因为它们不匹配。

Alice 和 Bob 交换这些公钥，并使用它们计算共享的机密协议。 虽然 Alice 和 Bob 不知道彼此的私钥，ECDH 数学会保证 Alice 和 Bob 将计算出同一共享机密协议。

> 只有 a、b 和 g^ab = g^ba 保密。 其他所有值都是公开的。

任何截获交换的人都能够复制 p、g 和两个公钥。 但是，要在不知道 Alice 和 Bob 的私钥的情况下从四个公开共享值生成共享机密协议，在计算上是不可行的。

使用暴力（即尝试所有可能的密钥）对 ECDH 加密的消息进行解密的难度与离散对数问题属同一级别。 不过，ECDH 算法使用较短的密钥即可达到相同程度的安全性，这是因为它依赖椭圆曲线而不是对数曲线。

#### ECDH 示例

下面的示例使用小整数来演示 ECDH 算法。

1. Alice 和 Bob 同意使用质数 p 和基础整数 g：

   p = 83, g = 8

2. Alice 选择机密整数 a = 9，然后向 Bob 发送 (g^a) mod p：

   (8^9) mod 83 = 5

3. Bob 选择机密整数 b = 21，然后向 Alice 发送 (g^b) mod p：

   (8^21) mod 83 = 18

4. Alice 计算 ( ( (g^b) mod p)^a) mod p：

   (18^9) mod 83 = 24

5. Bob 计算 ( ( (g^a) mod p)^b) mod p：

   (5^21) mod 83 = 24

由于 g^(ab) = g^(ba)，Alice 和 Bob 计算出相同的值 (24)。 该值就是共享机密协议。 Alice 和 Bob 使用这个值派生 AES 算法用来对其消息进行加密的密钥材料。

此示例使用值 24 生成共享机密协议。 由于这是一个小的值，它生成的加密消息很容易被暴力攻击破坏。 在实际情况中，p、g、a 和 b 是很大的数，需要计算机来生成相应的共享机密协议。

#### 协议的限制

由于 ECDH 密钥交换协议不验证公钥发送者的身份，因此无法阻止中间人攻击。 如果监听者 Mallory 截获了 Alice 的公钥，就可以替换为他自己的公钥，并将其发送给 Bob。 Mallory 还可以截获 Bob 的公钥，替换为他自己的公钥，并将其发送给 Alice。 这样，Mallory 就可以轻松地对 Alice 与 Bob 之间发送的任何消息进行解密。 他可以更改消息，用他自己的密钥对消息重新加密，然后将消息发送给接收者。

为了解决此问题，Alice 和 Bob 可以在交换公钥之前使用数字签名对公钥进行签名。 有两种方法可以实现此目的：

- 使用安全的媒体（例如语音通信或可信载运商）在双方之间传输数字签名密钥。
- 使用公共证书颁发机构 (CA) 向双方提供可信数字签名密钥。

在这两种情况下，都必须使用外部身份验证方案来验证公钥发送者的身份。比如DSA，RSA。